/* Generated by re2c 3.0 on Wed Dec 14 18:12:02 2022 */
#line 1 "regex_libtls.re"
// re2c regex_libtls.re -o regex_libtls.h
#ifdef UNITTEST
#include <assert.h>
#include <stdio.h>
#ifndef __always_inline
#define __always_inline inline
#endif
#endif

// return 1 if the regex match
// return 0 otherwise
static __always_inline int regex_libtls(const char *str, unsigned int len) {
    const char *YYCURSOR = str, *YYLIMIT = str + len, *YYMARKER;
    int count = 0;

#pragma unroll(60)
    for (int i=0;i<60;i++) {
    
#line 21 "regex_libtls.h"
{
    if (YYLIMIT <= YYCURSOR) { return count; }//{goto yy25;}
	char yych;
	yych = *YYCURSOR;
	switch (yych) {
        case 0x00: { return count; } //goto yy25;
		case 'l': goto yy4;
        default: { ++YYCURSOR; continue; } //goto yy2;
	}
//yy1:
//	++YYCURSOR;
#line 30 "regex_libtls.re"
//	{ return count; }
#line 36 "regex_libtls.h"
//yy2:
//	++YYCURSOR;
//yy3:
#line 28 "regex_libtls.re"
//	{ continue; }
#line 42 "regex_libtls.h"
yy4:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
		case 'i': goto yy5;
		default: {continue;} //goto yy3;
	}
yy5:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'b': goto yy7;
		default: goto yy6;
	}
yy6:
	YYCURSOR = YYMARKER;
	{continue;} //goto yy3;
yy7:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'c': goto yy8;
		case 'g': goto yy9;
		case 's': goto yy10;
		default: goto yy6;
	}
yy8:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'r': goto yy11;
		default: goto yy6;
	}
yy9:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'n': goto yy12;
		default: goto yy6;
	}
yy10:
	yych = *++YYCURSOR;
	switch (yych) {
		case 's': goto yy13;
		default: goto yy6;
	}
yy11:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'y': goto yy14;
		default: goto yy6;
	}
yy12:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'u': goto yy15;
		default: goto yy6;
	}
yy13:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'l': goto yy16;
		default: goto yy6;
	}
yy14:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'p': goto yy17;
		default: goto yy6;
	}
yy15:
	yych = *++YYCURSOR;
	switch (yych) {
		case 't': goto yy18;
		default: goto yy6;
	}
yy16:
	yych = *++YYCURSOR;
	switch (yych) {
		case '.': goto yy19;
		default: goto yy6;
	}
yy17:
	yych = *++YYCURSOR;
	switch (yych) {
		case 't': goto yy20;
		default: goto yy6;
	}
yy18:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'l': goto yy21;
		default: goto yy6;
	}
yy19:
	yych = *++YYCURSOR;
	switch (yych) {
		case 's': goto yy22;
		default: goto yy6;
	}
yy20:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'o': goto yy16;
		default: goto yy6;
	}
yy21:
	yych = *++YYCURSOR;
	switch (yych) {
		case 's': goto yy16;
		default: goto yy6;
	}
yy22:
	yych = *++YYCURSOR;
	switch (yych) {
        case 'o': {return 1;}//goto yy23;
		default: goto yy6;
	}
// yy23:
// #pragma unroll(30)
//     for (int i=0;i<30;i++) {
// 	yych = *++YYCURSOR;
// 	switch (yych) {
// 		case '+':
// 		case '-':
// 		case '.':
// 		case '0':
// 		case '1':
// 		case '2':
// 		case '3':
// 		case '4':
// 		case '5':
// 		case '6':
// 		case '7':
// 		case '8':
// 		case '9':
// 		case 'A':
// 		case 'B':
// 		case 'C':
// 		case 'D':
// 		case 'E':
// 		case 'F':
// 		case 'G':
// 		case 'H':
// 		case 'I':
// 		case 'J':
// 		case 'K':
// 		case 'L':
// 		case 'M':
// 		case 'N':
// 		case 'O':
// 		case 'P':
// 		case 'Q':
// 		case 'R':
// 		case 'S':
// 		case 'T':
// 		case 'U':
// 		case 'V':
// 		case 'W':
// 		case 'X':
// 		case 'Y':
// 		case 'Z':
// 		case '_':
// 		case 'a':
// 		case 'b':
// 		case 'c':
// 		case 'd':
// 		case 'e':
// 		case 'f':
// 		case 'g':
// 		case 'h':
// 		case 'i':
// 		case 'j':
// 		case 'k':
// 		case 'l':
// 		case 'm':
// 		case 'n':
// 		case 'o':
// 		case 'p':
// 		case 'q':
// 		case 'r':
// 		case 's':
// 		case 't':
// 		case 'u':
// 		case 'v':
// 		case 'w':
// 		case 'x':
// 		case 'y':
//         case 'z': continue;//goto yy23;
// 		default: { return 1; };
// 	}
//     }
//yy24:
#line 31 "regex_libtls.re"
//	{ return 1; }
#line 230 "regex_libtls.h"
//yy25:
#line 29 "regex_libtls.re"
//	{ return count; }
#line 234 "regex_libtls.h"
}
#line 32 "regex_libtls.re"

    }
    return 0;
}

#ifdef UNITTEST
#define TEST(s, size, r) assert(regex_libtls(s, size) == r)
int main() {
    // return 1 when the regex match
    TEST("/usr/libssl.so", sizeof("/usr/libssl.so"), 1);
    TEST("/usr/libsslz.so", sizeof("/usr/libsslz.so"), 0);
    TEST("/usr/libssl.so", sizeof("/usr/libssl.so")-1, 1); // no tailing \0
    TEST("/usr/libssl.so.1", sizeof("/usr/libssl.so.1"), 1);
    TEST("/usr/libcrypto.so.1", sizeof("/usr/libcrypto.so.1"), 1);
    TEST("/usr/libgnutls.so.1", sizeof("/usr/libgnutls.so.1"), 1);
    TEST("/usr/libssl.so.1.2", sizeof("/usr/libssl.so.1.2"), 1);
    TEST("/usr/libcrypto.so.1.2", sizeof("/usr/libcrypto.so.1.2"), 1);
    TEST("/usr/libgnutls.so.1.2", sizeof("/usr/libgnutls.so.1.2"), 1);
    printf("UNITTEST regex_libtls Success\n");
    return 0;
}
#endif
